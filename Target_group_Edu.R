## General example: build a sampling bias raster from occurrence CSV files
## - Objects that must already exist in the workspace: raster_var (template raster)

library(enmSdm)
library(raster)
library(sf)
library(dplyr)
library(readr)      # read_csv
library(purrr)      # map
library(terra)      # rast
library(spatialEco) # raster.transformation

# Folder containing the CSV files
occ_dir <- "path/to/occurrence_csvs"

# Output files
combined_out_csv <- "path/to/output/occurrences_thinned.csv"
bias_out_tif <- "path/to/output/Pollinators_bias.tif"

# Get the list of CSV files
setwd(occ_dir)
csv_files <- list.files(path = occ_dir, pattern = "*.csv")

# Read all CSV files and combine them into a single data frame
combined_df2 <- lapply(csv_files, read_csv) %>% bind_rows()

combined_df2 <- bind_rows(map(csv_files, ~read.csv(.x) %>% mutate(Species = sub(".csv$", "", .x))))

write.csv(combined_df2, combined_out_csv, row.names = FALSE)

Species <- rbind(combined_df[, 1:3], combined_df2[, 1:3])

# Aggregate by coordinates
sum_records <- as.data.frame(dplyr::count(Species, decimalLongitude, decimalLatitude))

# Extract coordinates
coords <- cbind(sum_records[, 1], sum_records[, 2])

# Create a scale
scale <- length(sum_records[, 3]) / sum(sum_records[, 3])
sum_records[, 4] <- sum_records[, 3] * scale

# Do a 2d kernel density estimation
target_density <- kde(coords, w = sum_records[, 4])

# Create raster
target_raster <- raster(target_density)

# Define the projection
crs(target_raster) <- crs(raster_var)

# Clip data to the same resolution/extent
target_raster <- resample(target_raster, raster_var, method = "bilinear")

# Mask bias file
target_raster <- mask(target_raster, raster_var)

# Normalize bias file between 0 and 1
target_raster <- target_raster - minValue(target_raster)
target_raster <- terra::rast(target_raster)
target_raster <- spatialEco::raster.transformation(target_raster, trans = "norm")

# Export the raster
plot(target_raster)
writeRaster(target_raster, bias_out_tif, overwrite = TRUE)


## Bias-based pseudo-absence (PA) replacement in biomod2
## Goal: replace PA generated by BIOMOD_FormatingData()
## with new PA points sampled using a bias raster as a probability surface.

library(biomod2)
library(raster)  # crop, mask, extent, rasterize, extract
library(sp)      # Spatial* classes (often used by biomod2 workflows)
library(dismo)   # randomPoints

## -------------------------------------------------------------------------
## Assumed objects already available in your workspace:
## - myResp: numeric/binary response vector (presence/absence)
## - myRespCoord: matrix/data.frame with 2 cols (x, y) for presences
## - myRespName: character, species name
## - ExplVar_cropped: RasterStack/RasterBrick of environmental variables
## - target_biasfile: RasterLayer with bias values (higher = more likely sampling)
## - Background_sp: SpatialPolygons* (or Spatial* object) defining the accessible area (M)
## -------------------------------------------------------------------------

## Basic checks (fail early if something is missing or malformed)
stopifnot(inherits(ExplVar_cropped, c("RasterStack", "RasterBrick")))
stopifnot(inherits(target_biasfile, "RasterLayer"))
stopifnot(is.matrix(myRespCoord) || is.data.frame(myRespCoord))
stopifnot(ncol(myRespCoord) == 2)

myRespCoord <- as.matrix(myRespCoord)
colnames(myRespCoord) <- c("x", "y")

## -------------------------------------------------------------------------
## 1) Create BIOMOD.formated.data with random PAs (placeholder strategy)
##    The replacement below will overwrite some of these PA coordinates.
## -------------------------------------------------------------------------
pa_reps <- 5

myBiomodata <- BIOMOD_FormatingData(
  resp.var   = myResp,
  expl.var   = ExplVar_cropped,
  resp.xy    = myRespCoord,
  resp.name  = myRespName,
  PA.nb.rep  = pa_reps,
  PA.nb.absences = ifelse(
    length(myResp) < round(raster::ncell(ExplVar_cropped[[1]]) * 0.05),
    length(myResp),
    round(raster::ncell(ExplVar_cropped[[1]]) * 0.05)
  ),
  PA.strategy    = "random",
  filter.raster  = TRUE,
  na.rm          = TRUE
)

## -------------------------------------------------------------------------
## 2) Crop and mask the bias raster to the background (accessible area)
##    This keeps the PA resampling coherent with the spatial domain used for modelling.
## -------------------------------------------------------------------------

## Buffer the background extent by one bias-raster cell (avoids edge clipping issues)
tb_dx <- raster::res(target_biasfile)[1]
tb_dy <- raster::res(target_biasfile)[2]

bg_e <- raster::extent(Background_sp)
bg_e_buf <- raster::extent(
  xmin(bg_e) - tb_dx, xmax(bg_e) + tb_dx,
  ymin(bg_e) - tb_dy, ymax(bg_e) + tb_dy
)

target_biasfile_cropped <- raster::crop(target_biasfile, bg_e_buf)

## Rasterize background to bias raster grid (coverage mask)
bg_cover <- raster::rasterize(
  x = Background_sp,
  y = target_biasfile_cropped,
  getCover = TRUE,
  background = 0
)

## Mask: keep only cells inside background (set outside to NA)
target_biasfile_cropped <- raster::mask(
  x = target_biasfile_cropped,
  mask = bg_cover > 0,
  maskvalue = FALSE,
  updatevalue = NA
)

## -------------------------------------------------------------------------
## 3) Bias-based PA replacement
##
## - for each PA replicate j, define y = j+1 (cyclic)
## - select rows that are PA in replicate j AND NOT PA in replicate y
## - resample ONLY those PA coordinates using the bias raster (prob=TRUE)
## - update both myBiomodata@coord and the extracted environmental table
## -------------------------------------------------------------------------

## Check original pseudo-absences
plot(myBiomodata)

# Loop over the 5 pseudo-absence (PA) replicates created by BIOMOD_FormatingData
for (j in 1:5) {
  
  # Define the "next" replicate index (cyclic): y = j + 1, and if j = 5 then y becomes 1
  y <- j + 1
  if (y > 5) y <- 1
  
  # Wrap the resampling step in tryCatch to avoid stopping the script if resampling fails for a replicate
  tryCatch({
    
    # Sample new PA coordinates using the bias raster as a probability surface
    # - mask: limits sampling to non-NA cells of the cropped/masked bias raster
    # - p: excludes presence coordinates from being sampled as absences (with excludep = TRUE)
    # - n: number of points to sample equals the number of PA rows that are TRUE in replicate j and FALSE in replicate y
    # - prob = TRUE: sampling probability is proportional to raster cell values (bias-weighted sampling)
    # - excludep = TRUE: enforces exclusion of points in p
    new_coords <- dismo::randomPoints(
      mask = target_biasfile_cropped,
      p = myRespCoord,
      n = nrow(myBiomodata@coord[myBiomodata@PA.table[, j] == TRUE & myBiomodata@PA.table[, y] == FALSE, ]),
      prob = TRUE,
      excludep = TRUE
    )
    
    # Replace the selected PA coordinates in myBiomodata@coord with the newly sampled coordinates
    myBiomodata@coord[myBiomodata@PA.table[, j] == TRUE & myBiomodata@PA.table[, y] == FALSE, ] <- new_coords
    
    # Update the environmental values (data.env.var) for the replaced PA rows by extracting predictors at new_coords
    myBiomodata@data.env.var[myBiomodata@PA.table[, j] == TRUE & myBiomodata@PA.table[, y] == FALSE, ] <-
      as.data.frame(raster::extract(ExplVar_cropped, new_coords))
    
  }, error = function(e) {
    
    # If an error occurs during resampling or replacement, print a message identifying the replicate and the error
    message(sprintf("PA resampling error at j=%d: %s", j, e$message))
    
  })
}


## Check new pseudo-absences
plot(myBiomodata)
